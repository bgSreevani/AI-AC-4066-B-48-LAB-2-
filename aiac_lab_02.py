# -*- coding: utf-8 -*-
"""AIAC LAB 02.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Fqf3r2HVa6W5nbPVbStPQXkjwPc1lhA4

# **Lab 2: Exploring Additional AI Coding Tools beyond Copilot – Gemini (Colab)**

***# Task 1: Statistical Summary for Survey Data***

❖ Scenario:
You are a data analyst intern working with survey responses stored as
numerical lists.
❖ Task:
Use Google Gemini in Colab to generate a Python function that reads a list
of numbers and calculates the mean, minimum, and maximum values.
❖ Expected Output:
➢ Correct Python function
➢ Output shown in Colab
➢ Screenshot of Gemini prompt and result
"""

def analyze_numbers(numbers):
    """
    Calculates the mean, minimum, and maximum of a list of numbers.

    Args:
        numbers (list): A list of numerical values.

    Returns:
        tuple: A tuple containing the mean, minimum, and maximum values.
               Returns (None, None, None) if the list is empty.
    """
    if not numbers:
        return None, None, None

    mean_value = sum(numbers) / len(numbers)
    min_value = min(numbers)
    max_value = max(numbers)

    return mean_value, min_value, max_value

# Example usage:
sample_data = [10, 20, 30, 40, 50, 5, 25]
mean, minimum, maximum = analyze_numbers(sample_data)

print(f"Sample Data: {sample_data}")
if mean is not None:
    print(f"Mean: {mean:.2f}")
    print(f"Minimum: {minimum}")
    print(f"Maximum: {maximum}")
else:
    print("The list is empty, no statistics to calculate.")

# Another example with an empty list:
empty_data = []
mean_empty, min_empty, max_empty = analyze_numbers(empty_data)
print(f"\nEmpty Data: {empty_data}")
if mean_empty is not None:
    print(f"Mean: {mean_empty:.2f}")
    print(f"Minimum: {min_empty}")
    print(f"Maximum: {max_empty}")
else:
    print("The list is empty, no statistics to calculate.")

"""# **Task 2: Armstrong Number – AI Comparison**

Scenario:
You are evaluating AI tools for numeric validation logic.
❖ Task:
Generate an Armstrong number checker using Gemini and GitHub
Copilot.
Compare their outputs, logic style, and clarity.
❖ Expected Output:
➢ Side-by-side comparison table
➢ Screenshots of prompts and generated code

# **Gemini AI**
"""

def is_armstrong_number(number):
    """
    Checks if a given number is an Armstrong number.

    An Armstrong number (or narcissistic number) is a number that is the sum
    of its own digits each raised to the power of the number of digits.

    Args:
        number (int): The integer to check.

    Returns:
        bool: True if the number is an Armstrong number, False otherwise.
    """
    if not isinstance(number, int) or number < 0:
        raise ValueError("Input must be a non-negative integer.")

    # Convert the number to a string to easily determine the number of digits
    num_str = str(number)
    n_digits = len(num_str)

    # Calculate the sum of each digit raised to the power of the total number of digits
    sum_of_powers = 0
    for digit_char in num_str:
        digit = int(digit_char)
        sum_of_powers += digit ** n_digits

    # Compare this sum with the original number
    return sum_of_powers == number

# Example Usage:
print("Checking Armstrong numbers:")
print(f"153 is Armstrong: {is_armstrong_number(153)}") # Expected: True (1^3 + 5^3 + 3^3 = 1 + 125 + 27 = 153)
print(f"9 is Armstrong: {is_armstrong_number(9)}")    # Expected: True (9^1 = 9)
print(f"370 is Armstrong: {is_armstrong_number(370)}")  # Expected: True (3^3 + 7^3 + 0^3 = 27 + 343 + 0 = 370)
print(f"1634 is Armstrong: {is_armstrong_number(1634)}") # Expected: True (1^4 + 6^4 + 3^4 + 4^4 = 1 + 1296 + 81 + 256 = 1634)
print(f"123 is Armstrong: {is_armstrong_number(123)}")  # Expected: False (1^3 + 2^3 + 3^3 = 1 + 8 + 27 = 36 != 123)
print(f"54748 is Armstrong: {is_armstrong_number(54748)}") # Expected: True

"""# **Git Hub Co-pilot code**"""

def is_armstrong(number: int) -> bool:
    """
    Check if a given number is an Armstrong number.

    An Armstrong number of 'n' digits is a number such that
    the sum of its digits raised to the power 'n' equals the number itself.
    """
    # Convert number to string to easily iterate over digits
    digits = str(number)
    num_digits = len(digits)

    # Compute sum of each digit raised to the power of num_digits
    total = sum(int(digit) ** num_digits for digit in digits)

    return total == number


# Example usage
if __name__ == "__main__":
    test_numbers = [153, 9474, 123, 407]
    for num in test_numbers:
        if is_armstrong(num):
            print(f"{num} is an Armstrong number.")
        else:
            print(f"{num} is NOT an Armstrong number.")

"""# **Task 4: Student Logic + AI Refactoring (Odd/Even Sum)**


❖ Scenario:
Company policy requires developers to write logic before using AI.
❖ Task:
Write a Python program that calculates the sum of odd and even numbers
in a tuple, then refactor it using any AI tool.
"""

# Original Code: Student Logic
def calculate_odd_even_sums_original(numbers_tuple):
    """
    Calculates the sum of odd and even numbers in a tuple.
    """
    odd_sum = 0
    even_sum = 0
    for num in numbers_tuple:
        if num % 2 == 0:
            even_sum += num
        else:
            odd_sum += num
    return odd_sum, even_sum

# Example Usage for Original Code:
data_tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
odd_total_orig, even_total_orig = calculate_odd_even_sums_original(data_tuple)
print(f"Original Code Results for {data_tuple}:")
print(f"  Sum of odd numbers: {odd_total_orig}")
print(f"  Sum of even numbers: {even_total_orig}")
print("\n" + "="*40 + "\n")

# Refactored Code (AI-enhanced simulation)
def calculate_odd_even_sums_refactored(numbers_tuple):
    """
    Calculates the sum of odd and even numbers in a tuple (refactored using AI).
    Uses list comprehensions for a more concise and Pythonic approach.
    """
    even_sum = sum(num for num in numbers_tuple if num % 2 == 0)
    odd_sum = sum(num for num in numbers_tuple if num % 2 != 0)
    return odd_sum, even_sum

# Example Usage for Refactored Code:
data_tuple_refactored = (11, 12, 13, 14, 15, 16, 17, 18, 19, 20)
odd_total_refactored, even_total_refactored = calculate_odd_even_sums_refactored(data_tuple_refactored)
print(f"Refactored Code Results for {data_tuple_refactored}:")
print(f"  Sum of odd numbers: {odd_total_refactored}")
print(f"  Sum of even numbers: {even_total_refactored}")

# Example with empty tuple
empty_tuple = ()
odd_empty_orig, even_empty_orig = calculate_odd_even_sums_original(empty_tuple)
odd_empty_ref, even_empty_ref = calculate_odd_even_sums_refactored(empty_tuple)

print("\n" + "="*40 + "\n")
print(f"Original Code Results for {empty_tuple}:")
print(f"  Sum of odd numbers: {odd_empty_orig}")
print(f"  Sum of even numbers: {even_empty_orig}")
print(f"Refactored Code Results for {empty_tuple}:")
print(f"  Sum of odd numbers: {odd_empty_ref}")
print(f"  Sum of even numbers: {even_empty_ref}")

